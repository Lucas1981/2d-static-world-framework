/**
* This class can create behaviour for the actors making them turn in any direction
* when they hit a wall, rotating either clockwise or counterclockwise, starting off in
* any direction
*/

import Actor from '../lib/Actor';
import IMovable from '../lib/IMovable';
import global from '../lib/Global';

const pixelsPerSecond = 100;

const directions = [
  // The directions in clockwise fashion
  { x: 0, y: -1 }, // up
  { x: 1, y: -1 }, // upper-right
  { x: 1, y: 0}, // right
  { x: 1, y: 1 }, // lower-right
  { x: 0, y: 1 }, // down
  { x: -1, y: 1 }, // lower-left
  { x: -1, y: 0 }, // left
  { x: -1, y: -1 }, // upper-left
]

export default abstract class UntilHitsMover implements IMovable {
  private direction: any;
  private directionIndex: number;

  constructor(
    private numberOfTurns: number = 2,
    private turnDirection: number = 1,
    initialDirection: number = 0,
  ) {
    this.directionIndex = initialDirection;
    this.direction = directions[this.directionIndex];
  }

  public progress(actor: Actor) {
    const elapsedTime: number = global.clock.elapsedTime;
    // Limit the possible movement to a unit - 1 max
    const movement: number = Math.min(pixelsPerSecond * elapsedTime / 1000, global.config.unit - 1);
    const gridX: number = Math.floor(actor.x / global.config.unit);
    const gridY: number = Math.floor(actor.y / global.config.unit);
    // Add the assument movement to the probes
    let probeY: number = actor.y + (movement * this.direction.y);
    let probeX: number = actor.x + (movement * this.direction.x);

    // Do we hit a wall if we are trying this?
    if (actor.checkGrid(probeX, probeY)) {
      // If not, do the usual
      actor.x = probeX;
      actor.y = probeY;
    } else {
      // Otherwise, make sure the actor is as close to the wall as he can get
      if(this.direction.x === 1) actor.x = ((gridX + 1) * global.config.unit) - (global.config.unit / 2);
      if(this.direction.x === -1) actor.x = (gridX * global.config.unit) + (global.config.unit / 2);
      if(this.direction.y === 1) actor.y = ((gridY + 1) * global.config.unit) - (global.config.unit / 2);
      if(this.direction.y === -1) actor.y = (gridY * global.config.unit) + (global.config.unit / 2);

      // And change the direction in the way specified
      this.directionIndex = (this.directionIndex + (this.turnDirection * this.numberOfTurns) + directions.length) % directions.length;
      this.direction = directions[this.directionIndex];
    }
  }
}
